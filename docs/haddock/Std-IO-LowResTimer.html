<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Std.IO.LowResTimer</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Std-IO-LowResTimer.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">stdio-0.1.0.0: Standard Input and Output for Haskell</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) Winterland 2017-2018</td></tr><tr><th>License</th><td>BSD</td></tr><tr><th>Maintainer</th><td>drkoster@qq.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>non-portable</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Std.IO.LowResTimer</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">low resolution timers</a></li><li><a href="#g:2">low resolution timer manager</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provide low resolution (0.1s) timers using a timing wheel of size 128 per capability,
each timer thread will automatically started or stopped based on demannd. register or cancel a timeout is O(1),
and each step only need scan n/128 items given timers are registered in an even fashion.</p><p>This timer is particularly suitable for high concurrent approximated I/O timeout scheduling.
You should not rely on it to provide timing information since it's not very accurate.</p><p>Reference:</p><ul><li><a href="https://github.com/netty/netty/blob/4.1/common/src/main/java/io/netty/util/HashedWheelTimer.java">https://github.com/netty/netty/blob/4.1/common/src/main/java/io/netty/util/HashedWheelTimer.java</a></li><li><a href="http://www.cse.wustl.edu/~cdgill/courses/cs6874/TimingWheels.ppt">http://www.cse.wustl.edu/~cdgill/courses/cs6874/TimingWheels.ppt</a></li></ul></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:registerLowResTimer">registerLowResTimer</a> :: Int -&gt; IO () -&gt; IO <a href="Std-IO-LowResTimer.html#t:LowResTimer">LowResTimer</a></li><li class="src short"><a href="#v:registerLowResTimerOn">registerLowResTimerOn</a> :: <a href="Std-IO-LowResTimer.html#t:LowResTimerManager">LowResTimerManager</a> -&gt; Int -&gt; IO () -&gt; IO <a href="Std-IO-LowResTimer.html#t:LowResTimer">LowResTimer</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:LowResTimer">LowResTimer</a></li><li class="src short"><a href="#v:queryLowResTimer">queryLowResTimer</a> :: <a href="Std-IO-LowResTimer.html#t:LowResTimer">LowResTimer</a> -&gt; IO Int</li><li class="src short"><a href="#v:cancelLowResTimer">cancelLowResTimer</a> :: <a href="Std-IO-LowResTimer.html#t:LowResTimer">LowResTimer</a> -&gt; IO Int</li><li class="src short"><a href="#v:cancelLowResTimer_">cancelLowResTimer_</a> :: <a href="Std-IO-LowResTimer.html#t:LowResTimer">LowResTimer</a> -&gt; IO ()</li><li class="src short"><a href="#v:debounce">debounce</a> :: Int -&gt; IO a -&gt; IO (IO a)</li><li class="src short"><span class="keyword">data</span> <a href="#t:LowResTimerManager">LowResTimerManager</a></li><li class="src short"><a href="#v:getLowResTimerManager">getLowResTimerManager</a> :: IO <a href="Std-IO-LowResTimer.html#t:LowResTimerManager">LowResTimerManager</a></li><li class="src short"><a href="#v:isLowResTimerManagerRunning">isLowResTimerManagerRunning</a> :: <a href="Std-IO-LowResTimer.html#t:LowResTimerManager">LowResTimerManager</a> -&gt; IO Bool</li><li class="src short"><a href="#v:lowResTimerManagerCapabilitiesChanged">lowResTimerManagerCapabilitiesChanged</a> :: IO ()</li></ul></div><div id="interface"><h1 id="g:1">low resolution timers</h1><div class="top"><p class="src"><a id="v:registerLowResTimer" class="def">registerLowResTimer</a> <a href="#v:registerLowResTimer" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Int</td><td class="doc"><p>timout in unit of 100 milliseconds / 0.1s</p></td></tr><tr><td class="src">-&gt; IO ()</td><td class="doc"><p>the action you want to perform, it should not block</p></td></tr><tr><td class="src">-&gt; IO <a href="Std-IO-LowResTimer.html#t:LowResTimer">LowResTimer</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Register a new timer on current capability's timer manager, start the timing wheel if it's not turning.</p><p>If the action could block, you may want to run it in another thread. Example to kill a thread after 10s:</p><pre>  registerLowResTimer 100 (forkIO $ killThread tid)
</pre></div></div><div class="top"><p class="src"><a id="v:registerLowResTimerOn" class="def">registerLowResTimerOn</a> <a href="#v:registerLowResTimerOn" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Std-IO-LowResTimer.html#t:LowResTimerManager">LowResTimerManager</a></td><td class="doc"><p>a low resolution timer manager</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>timout in unit of 100 milliseconds / 0.1s</p></td></tr><tr><td class="src">-&gt; IO ()</td><td class="doc"><p>the action you want to perform, it should not block</p></td></tr><tr><td class="src">-&gt; IO <a href="Std-IO-LowResTimer.html#t:LowResTimer">LowResTimer</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Same as <code><a href="Std-IO-LowResTimer.html#v:registerLowResTimer">registerLowResTimer</a></code>, but allow you choose timer manager.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:LowResTimer" class="def">LowResTimer</a> <a href="#t:LowResTimer" class="selflink">#</a></p><div class="doc"><p>Timer registered by <code><a href="Std-IO-LowResTimer.html#v:registerLowResTimer">registerLowResTimer</a></code> or <code><a href="Std-IO-LowResTimer.html#v:registerLowResTimerOn">registerLowResTimerOn</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:queryLowResTimer" class="def">queryLowResTimer</a> :: <a href="Std-IO-LowResTimer.html#t:LowResTimer">LowResTimer</a> -&gt; IO Int <a href="#v:queryLowResTimer" class="selflink">#</a></p><div class="doc"><p>Query how many ticks (~0.1s) remain before timer firing.</p><p>A return value &lt;= 0 indictate the timer is firing or fired.</p></div></div><div class="top"><p class="src"><a id="v:cancelLowResTimer" class="def">cancelLowResTimer</a> :: <a href="Std-IO-LowResTimer.html#t:LowResTimer">LowResTimer</a> -&gt; IO Int <a href="#v:cancelLowResTimer" class="selflink">#</a></p><div class="doc"><p>Cancel a timer, return the remaining ticks.</p><p>This function have no effect after the timer is fired.</p></div></div><div class="top"><p class="src"><a id="v:cancelLowResTimer_" class="def">cancelLowResTimer_</a> :: <a href="Std-IO-LowResTimer.html#t:LowResTimer">LowResTimer</a> -&gt; IO () <a href="#v:cancelLowResTimer_" class="selflink">#</a></p><div class="doc"><pre>void . cancelLowResTimer</pre></div></div><div class="top"><p class="src"><a id="v:debounce" class="def">debounce</a> <a href="#v:debounce" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Int</td><td class="doc"><p>cache time in unit of 100 milliseconds / 0.1s</p></td></tr><tr><td class="src">-&gt; IO a</td><td class="doc"><p>the original IO action</p></td></tr><tr><td class="src">-&gt; IO (IO a)</td><td class="doc"><p>debounced IO action</p></td></tr></table></div><div class="doc"><p>Cache result of an IO action for give time t.</p><p>This combinator is useful when you want to share IO result within a period, the action will be called
 on demand, and the result will be cached for t milliseconds.</p><p>One common way to get a shared periodical updated value is to start a seperate thread,
 but doing that will stop system from being idle, which stop idle GC from running,
 and in turn disable deadlock detection, which is too bad. This function solves that.</p></div></div><h1 id="g:2">low resolution timer manager</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:LowResTimerManager" class="def">LowResTimerManager</a> <a href="#t:LowResTimerManager" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:getLowResTimerManager" class="def">getLowResTimerManager</a> :: IO <a href="Std-IO-LowResTimer.html#t:LowResTimerManager">LowResTimerManager</a> <a href="#v:getLowResTimerManager" class="selflink">#</a></p><div class="doc"><p>Get a <code><a href="Std-IO-LowResTimer.html#t:LowResTimerManager">LowResTimerManager</a></code> for current thread.</p></div></div><div class="top"><p class="src"><a id="v:isLowResTimerManagerRunning" class="def">isLowResTimerManagerRunning</a> :: <a href="Std-IO-LowResTimer.html#t:LowResTimerManager">LowResTimerManager</a> -&gt; IO Bool <a href="#v:isLowResTimerManagerRunning" class="selflink">#</a></p><div class="doc"><p>Check if a timer manager's wheel is turning</p><p>This is mostly for testing purpose.</p></div></div><div class="top"><p class="src"><a id="v:lowResTimerManagerCapabilitiesChanged" class="def">lowResTimerManagerCapabilitiesChanged</a> :: IO () <a href="#v:lowResTimerManagerCapabilitiesChanged" class="selflink">#</a></p><div class="doc"><p>Create new low resolution timer manager on capability change.</p><p>Since low resolution timer manager is not hooked into RTS, you're responsible to call this function
 after you call <code>setNumCapabilities</code> to match timer manager array size with new capability number.</p><p>This is not a must though, when we fetch timer manager we always take a modulo.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.3</p></div></body></html>