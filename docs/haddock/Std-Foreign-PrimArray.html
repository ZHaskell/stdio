<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Std.Foreign.PrimArray</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Std-Foreign-PrimArray.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">stdio-0.1.0.0: Standard Input and Output for Haskell</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) Winterland 2017-2018</td></tr><tr><th>License</th><td>BSD</td></tr><tr><th>Maintainer</th><td>drkoster@qq.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>non-portable</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Std.Foreign.PrimArray</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Unsafe FFI</a></li><li><a href="#g:2">Safe FFI</a></li><li><a href="#g:3">Pointer helpers</a></li><li><a href="#g:4">re-export</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provide functions for using <code><a href="Std-Data-Array.html#t:PrimArray">PrimArray</a></code> and <code><a href="Std-Data-Vector.html#t:PrimVector">PrimVector</a></code> with GHC FFI(Foreign function interface).
Since GHC runtime is garbaged collected, we have a quite complex story when passing primitive arrays to FFI.
We have two types of primitive array in GHC, with the objective to minimize overall memory management cost:</p><ul><li>Small primitive arrays created with <code>newPrimArray</code> are directly allocated on GHC heap, which can be moved
    by GHC garbage collector, we call these arrays <code>unpinned</code>. Allocating these array is cheap, we only need
    to check heap limit and bump heap pointer just like any other haskell heap objects. But we will pay GC cost
    , which is OK for small arrays.</li><li>Large primitive array and those created with <code><a href="Std-Data-Array.html#v:newPinnedPrimArray">newPinnedPrimArray</a></code> are allocated on GHC managed memory blocks,
    which is also traced by garbage collector, but will never moved before freed, thus are called <code>pinned</code>.
    Allocating these arrays are bit more expensive since it's more like how <code>malloc</code> works, but we don't have to
    pay for GC cost.</li></ul><p>Beside the <code>pinned/unpinned</code> difference, we also have two types of FFI calls in GHC:</p><ul><li>Safe FFI call annotated with <code>safe</code> keyword. These calls are executed on separated OS thread, which can be
    running concurrently with GHC garbage collector, thus we want to make sure only pinned arrays are passed.
    The main use case for <code>safe</code> FFIs are long running functions, for example, doing I/O polling.
    Since these calls are running on separated OS thread, haskell thread on original OS thread will not be affected.</li><li>Unsafe FFI call annotated with <code>unsafe</code> keyword. These calls are executed on the same OS thread which is
    running the haskell side FFI code, which will in turn stop GHC from doing a garbage collection. We can pass
    both <code>pinned</code> and <code>unpinned</code> arrays in this case. The use case for <code>unsafe</code> FFIs are short/small functions,
    which can be treated like a fat primitive operations, such as <code>memcpy</code>, <code>memcmp</code>. Using <code>unsafe</code> FFI with
    long running functions will effectively block GHC runtime thread from running any other haskell thread, which
    is dangerous. Even if you use threaded runtime and expect your haskell thread can be stolen by other OS thread,
    but this will not work since GHC garbage collector will refuse to run if one of the OS thread is blocked by
    FFI calls.</li></ul><p>Base on above analysis, we have following FFI strategy table.</p><p>+--------------+---------------+---------------+
  | FFI   Array |    pinned     |   unpinned    |
  +--------------+---------------+---------------+
  |   unsafe     | directly pass | directly pass |
  +--------------+---------------+---------------+
  |     safe     | directly pass |  make a copy  |
  +--------------+---------------+---------------+</p><p>In this module, we separate safe and unsafe FFI handling due to the strategy difference: if the user can guarantee
the FFI are unsafe, we can save an extra copy and pinned allocation. Mistakenly using unsafe function with safe FFI
will result in segfault.</p><p>For convention you should always use `Ptr a` as the tagged pointer type, and <code>Addr</code> as the raw address type, use `addrToPtr/ptrToAddr` to cast between them if needed.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:withPrimArrayUnsafe">withPrimArrayUnsafe</a> :: <span class="keyword">forall</span> m a b. (PrimMonad m, <a href="Std-Data-Array.html#t:Prim">Prim</a> a) =&gt; <a href="Std-Data-Array.html#t:PrimArray">PrimArray</a> a -&gt; (ByteArray# -&gt; Int -&gt; m b) -&gt; m b</li><li class="src short"><a href="#v:withMutablePrimArrayUnsafe">withMutablePrimArrayUnsafe</a> :: <span class="keyword">forall</span> m a b. (PrimMonad m, <a href="Std-Data-Array.html#t:Prim">Prim</a> a) =&gt; <a href="Std-Data-Array.html#t:MutablePrimArray">MutablePrimArray</a> (PrimState m) a -&gt; (MutableByteArray# (PrimState m) -&gt; Int -&gt; m b) -&gt; m b</li><li class="src short"><a href="#v:withPrimVectorUnsafe">withPrimVectorUnsafe</a> :: <span class="keyword">forall</span> m a b. (PrimMonad m, <a href="Std-Data-Array.html#t:Prim">Prim</a> a) =&gt; <a href="Std-Data-Vector.html#t:PrimVector">PrimVector</a> a -&gt; (ByteArray# -&gt; Int -&gt; Int -&gt; m b) -&gt; m b</li><li class="src short"><a href="#v:withPrimUnsafe">withPrimUnsafe</a> :: <span class="keyword">forall</span> m a b. (PrimMonad m, <a href="Std-Data-Array.html#t:Prim">Prim</a> a) =&gt; (MutableByteArray# (PrimState m) -&gt; m b) -&gt; m (a, b)</li><li class="src short"><a href="#v:withPrimArraySafe">withPrimArraySafe</a> :: <a href="Std-Data-Array.html#t:Prim">Prim</a> a =&gt; <a href="Std-Data-Array.html#t:PrimArray">PrimArray</a> a -&gt; (Ptr a -&gt; Int -&gt; IO b) -&gt; IO b</li><li class="src short"><a href="#v:withMutablePrimArraySafe">withMutablePrimArraySafe</a> :: <a href="Std-Data-Array.html#t:Prim">Prim</a> a =&gt; <a href="Std-Data-Array.html#t:MutablePrimArray">MutablePrimArray</a> <a href="Std-Data-Array.html#t:RealWorld">RealWorld</a> a -&gt; (Ptr a -&gt; Int -&gt; IO b) -&gt; IO b</li><li class="src short"><a href="#v:withPrimVectorSafe">withPrimVectorSafe</a> :: <span class="keyword">forall</span> a b. <a href="Std-Data-Array.html#t:Prim">Prim</a> a =&gt; <a href="Std-Data-Vector.html#t:PrimVector">PrimVector</a> a -&gt; (Ptr a -&gt; Int -&gt; IO b) -&gt; IO b</li><li class="src short"><a href="#v:withPrimSafe">withPrimSafe</a> :: <span class="keyword">forall</span> a b. <a href="Std-Data-Array.html#t:Prim">Prim</a> a =&gt; (Ptr a -&gt; IO b) -&gt; IO (a, b)</li><li class="src short"><a href="#v:clearPtr">clearPtr</a> :: Ptr a -&gt; Int -&gt; IO ()</li><li class="src short"><a href="#v:addrToPtr">addrToPtr</a> :: Addr -&gt; Ptr a</li><li class="src short"><a href="#v:ptrToAddr">ptrToAddr</a> :: Ptr a -&gt; Addr</li><li class="src short"><a href="#v:castPtr">castPtr</a> :: Ptr a -&gt; Ptr b</li></ul></div><div id="interface"><h2 id="g:1">Unsafe FFI</h2><div class="top"><p class="src"><a id="v:withPrimArrayUnsafe" class="def">withPrimArrayUnsafe</a> :: <span class="keyword">forall</span> m a b. (PrimMonad m, <a href="Std-Data-Array.html#t:Prim">Prim</a> a) =&gt; <a href="Std-Data-Array.html#t:PrimArray">PrimArray</a> a -&gt; (ByteArray# -&gt; Int -&gt; m b) -&gt; m b <a href="#v:withPrimArrayUnsafe" class="selflink">#</a></p><div class="doc"><p>Pass primitive array to unsafe FFI as pointer.</p><p>Enable <code>UnliftedFFITypes</code> extension in your haskell code, use proper pointer type and <code>CSize/CSsize</code>
 to marshall <code>ByteArray#</code> and <code>Int</code> arguments on C side.</p><p>The second <code>Int</code> arguement is the element size not the bytes size.</p><p>Don't cast <code>ByteArray#</code> to <code>Addr#</code> since the heap object offset is hard-coded in code generator:
 <a href="https://github.com/ghc/ghc/blob/master/compiler/codeGen/StgCmmForeign.hs#L520">https://github.com/ghc/ghc/blob/master/compiler/codeGen/StgCmmForeign.hs#L520</a></p><p>In haskell side we use type system to distinguish immutable / mutable arrays, but in C side we can't.
 So it's users' responsibility to make sure the array content is not mutated. Otherwise please thaw
 the array and use <code><a href="Std-Foreign-PrimArray.html#v:withMutablePrimArrayUnsafe">withMutablePrimArrayUnsafe</a></code> instead.</p><p>USE THIS FUNCTION WITH UNSAFE FFI CALL ONLY.</p></div></div><div class="top"><p class="src"><a id="v:withMutablePrimArrayUnsafe" class="def">withMutablePrimArrayUnsafe</a> :: <span class="keyword">forall</span> m a b. (PrimMonad m, <a href="Std-Data-Array.html#t:Prim">Prim</a> a) =&gt; <a href="Std-Data-Array.html#t:MutablePrimArray">MutablePrimArray</a> (PrimState m) a -&gt; (MutableByteArray# (PrimState m) -&gt; Int -&gt; m b) -&gt; m b <a href="#v:withMutablePrimArrayUnsafe" class="selflink">#</a></p><div class="doc"><p>Pass mutable primitive array to unsafe FFI as pointer.</p><p>The mutable version of <code><a href="Std-Foreign-PrimArray.html#v:withPrimArrayUnsafe">withPrimArrayUnsafe</a></code>.</p><p>USE THIS FUNCTION WITH UNSAFE FFI CALL ONLY.</p></div></div><div class="top"><p class="src"><a id="v:withPrimVectorUnsafe" class="def">withPrimVectorUnsafe</a> :: <span class="keyword">forall</span> m a b. (PrimMonad m, <a href="Std-Data-Array.html#t:Prim">Prim</a> a) =&gt; <a href="Std-Data-Vector.html#t:PrimVector">PrimVector</a> a -&gt; (ByteArray# -&gt; Int -&gt; Int -&gt; m b) -&gt; m b <a href="#v:withPrimVectorUnsafe" class="selflink">#</a></p><div class="doc"><p>Pass <code><a href="Std-Data-Vector.html#t:PrimVector">PrimVector</a></code> to unsafe FFI as pointer</p><p>The <code><a href="Std-Data-Vector.html#t:PrimVector">PrimVector</a></code> version of <code><a href="Std-Foreign-PrimArray.html#v:withPrimArrayUnsafe">withPrimArrayUnsafe</a></code>.</p><p>The second <code>Int</code> arguement is the first element offset, the third <code>Int</code> argument is the
 element length.</p><p>USE THIS FUNCTION WITH UNSAFE FFI CALL ONLY.</p></div></div><div class="top"><p class="src"><a id="v:withPrimUnsafe" class="def">withPrimUnsafe</a> :: <span class="keyword">forall</span> m a b. (PrimMonad m, <a href="Std-Data-Array.html#t:Prim">Prim</a> a) =&gt; (MutableByteArray# (PrimState m) -&gt; m b) -&gt; m (a, b) <a href="#v:withPrimUnsafe" class="selflink">#</a></p><div class="doc"><p>Create an one element primitive array and use it as a pointer to the primitive element.</p><p>Return the element and the computation result.</p><p>USE THIS FUNCTION WITH UNSAFE FFI CALL ONLY.</p></div></div><h2 id="g:2">Safe FFI</h2><div class="top"><p class="src"><a id="v:withPrimArraySafe" class="def">withPrimArraySafe</a> :: <a href="Std-Data-Array.html#t:Prim">Prim</a> a =&gt; <a href="Std-Data-Array.html#t:PrimArray">PrimArray</a> a -&gt; (Ptr a -&gt; Int -&gt; IO b) -&gt; IO b <a href="#v:withPrimArraySafe" class="selflink">#</a></p><div class="doc"><p>Pass primitive array to safe FFI as pointer.</p><p>Use proper pointer type and <code>CSize/CSsize</code> to marshall <code>Ptr a</code> and <code>Int</code> arguments on C side.
 The memory pointed by 'Ptr a' will not moved.</p><p>The second <code>Int</code> arguement is the element size not the bytes size.</p></div></div><div class="top"><p class="src"><a id="v:withMutablePrimArraySafe" class="def">withMutablePrimArraySafe</a> :: <a href="Std-Data-Array.html#t:Prim">Prim</a> a =&gt; <a href="Std-Data-Array.html#t:MutablePrimArray">MutablePrimArray</a> <a href="Std-Data-Array.html#t:RealWorld">RealWorld</a> a -&gt; (Ptr a -&gt; Int -&gt; IO b) -&gt; IO b <a href="#v:withMutablePrimArraySafe" class="selflink">#</a></p><div class="doc"><p>Pass mutable primitive array to unsafe FFI as pointer.</p><p>The mutable version of <code><a href="Std-Foreign-PrimArray.html#v:withPrimArraySafe">withPrimArraySafe</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:withPrimVectorSafe" class="def">withPrimVectorSafe</a> :: <span class="keyword">forall</span> a b. <a href="Std-Data-Array.html#t:Prim">Prim</a> a =&gt; <a href="Std-Data-Vector.html#t:PrimVector">PrimVector</a> a -&gt; (Ptr a -&gt; Int -&gt; IO b) -&gt; IO b <a href="#v:withPrimVectorSafe" class="selflink">#</a></p><div class="doc"><p>Pass <code><a href="Std-Data-Vector.html#t:PrimVector">PrimVector</a></code> to unsafe FFI as pointer</p><p>The <code><a href="Std-Data-Vector.html#t:PrimVector">PrimVector</a></code> version of <code><a href="Std-Foreign-PrimArray.html#v:withPrimArraySafe">withPrimArraySafe</a></code>. The <code>Ptr</code> is already pointed
 to the first element, thus no offset is provided.</p></div></div><div class="top"><p class="src"><a id="v:withPrimSafe" class="def">withPrimSafe</a> :: <span class="keyword">forall</span> a b. <a href="Std-Data-Array.html#t:Prim">Prim</a> a =&gt; (Ptr a -&gt; IO b) -&gt; IO (a, b) <a href="#v:withPrimSafe" class="selflink">#</a></p><div class="doc"><p>Create an one element primitive array and use it as a pointer to the primitive element.</p></div></div><h2 id="g:3">Pointer helpers</h2><div class="top"><p class="src"><a id="v:clearPtr" class="def">clearPtr</a> :: Ptr a -&gt; Int -&gt; IO () <a href="#v:clearPtr" class="selflink">#</a></p><div class="doc"><p>Zero a structure.</p><p>There's no <code>Storable</code> or <code><a href="Std-Data-Array.html#t:Prim">Prim</a></code> constraint on <code>a</code> type, thus the length
 should be given in bytes.</p></div></div><div class="top"><p class="src"><a id="v:addrToPtr" class="def">addrToPtr</a> :: Addr -&gt; Ptr a <a href="#v:addrToPtr" class="selflink">#</a></p><div class="doc"><p>Cast between raw address and tagged pointer.</p></div></div><div class="top"><p class="src"><a id="v:ptrToAddr" class="def">ptrToAddr</a> :: Ptr a -&gt; Addr <a href="#v:ptrToAddr" class="selflink">#</a></p><div class="doc"><p>Cast between tagged pointer and raw address.</p></div></div><div class="top"><p class="src"><a id="v:castPtr" class="def">castPtr</a> :: Ptr a -&gt; Ptr b <a href="#v:castPtr" class="selflink">#</a></p></div><h2 id="g:4">re-export</h2></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.3</p></div></body></html>